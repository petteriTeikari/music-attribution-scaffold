"""AcoustID fingerprint connector.

Audio fingerprinting via AcoustID / Chromaprint.  Given an audio file,
generates a Chromaprint fingerprint and looks it up against the AcoustID
database to find matching MusicBrainz recording IDs.  This answers the
question *"what recording is this?"* — the first step before attribution
metadata can be attached.

The ``source_confidence`` for AcoustID results is the AcoustID match
score (0.0-1.0), which reflects the fingerprint similarity between the
query audio and the database entry.  High scores (> 0.9) indicate near-
certain identification.

Notes
-----
``acoustid.fingerprint_file`` and ``acoustid.lookup`` are synchronous —
they are wrapped in ``asyncio.to_thread()`` to avoid blocking the event
loop.

AcoustID results link directly to MusicBrainz recording IDs (MBIDs),
enabling seamless cross-referencing with the ``MusicBrainzConnector``
for full metadata enrichment.
"""

from __future__ import annotations

import asyncio
import logging
from datetime import UTC, datetime
from pathlib import Path

import acoustid

from music_attribution.etl.rate_limiter import TokenBucketRateLimiter
from music_attribution.schemas.enums import EntityTypeEnum, SourceEnum
from music_attribution.schemas.normalized import (
    IdentifierBundle,
    NormalizedRecord,
    SourceMetadata,
)

logger = logging.getLogger(__name__)


class AcoustIDConnector:
    """ETL connector for the AcoustID fingerprint service.

    Provides async methods for fingerprinting audio files and looking up
    fingerprints against the AcoustID database to resolve MusicBrainz
    recording IDs.

    Parameters
    ----------
    api_key : str
        AcoustID API key (obtain from https://acoustid.org/).
    rate : float, optional
        Maximum requests per second, by default 3.0 (AcoustID policy).
    max_retries : int, optional
        Maximum retry attempts on transient API errors, by default 3.
        Uses exponential backoff (2^attempt seconds).

    Attributes
    ----------
    _rate_limiter : TokenBucketRateLimiter
        Token-bucket limiter enforcing the per-second request cap.

    Examples
    --------
    >>> connector = AcoustIDConnector(api_key="your-key")
    >>> fp, dur = await connector.fingerprint_file(Path("song.mp3"))
    >>> records = await connector.lookup(fp, dur)
    >>> records[0].source
    <SourceEnum.ACOUSTID: 'acoustid'>
    """

    def __init__(
        self,
        api_key: str,
        rate: float = 3.0,
        max_retries: int = 3,
    ) -> None:
        self._api_key = api_key
        self._rate_limiter = TokenBucketRateLimiter(rate=rate, capacity=3)
        self._max_retries = max_retries

    async def fingerprint_file(self, file_path: Path) -> tuple[str, int]:
        """Generate a Chromaprint fingerprint from an audio file.

        Delegates to ``acoustid.fingerprint_file`` in a worker thread
        to avoid blocking the event loop.

        Parameters
        ----------
        file_path : Path
            Path to the audio file (MP3, FLAC, WAV, OGG, etc.).

        Returns
        -------
        tuple[str, int]
            A 2-tuple of ``(fingerprint_string, duration_in_seconds)``.

        Raises
        ------
        acoustid.FingerprintGenerationError
            If Chromaprint cannot process the audio file.
        """
        duration, fingerprint = await asyncio.to_thread(acoustid.fingerprint_file, str(file_path))
        return fingerprint, duration

    async def lookup(self, fingerprint: str, duration: int) -> list[NormalizedRecord]:
        """Look up a fingerprint against the AcoustID database.

        Queries AcoustID with the fingerprint and duration, then
        transforms matched results into ``NormalizedRecord`` objects
        with MusicBrainz recording IDs for cross-referencing.

        Parameters
        ----------
        fingerprint : str
            Chromaprint fingerprint string generated by
            ``fingerprint_file()``.
        duration : int
            Audio duration in seconds.

        Returns
        -------
        list[NormalizedRecord]
            Matching recordings sorted by confidence score (descending).
            Empty list if no matches are found.

        Raises
        ------
        acoustid.WebServiceError
            If the AcoustID API returns an error after all retries.
        """
        response = await self._api_call(
            acoustid.lookup,
            self._api_key,
            fingerprint,
            duration,
            meta="recordings",
        )
        return self.transform_lookup_results(response)

    def transform_lookup_results(self, response: dict) -> list[NormalizedRecord]:
        """Transform an AcoustID lookup response into NormalizedRecords.

        Each AcoustID result may contain multiple MusicBrainz recording
        matches.  Every recording is emitted as a separate
        ``NormalizedRecord`` with:

        * ``source_confidence`` set to the AcoustID match score
        * ``identifiers.mbid`` linking to the MusicBrainz recording
        * ``identifiers.acoustid`` linking to the AcoustID entry

        Parameters
        ----------
        response : dict
            Raw AcoustID API response containing a ``results`` list.

        Returns
        -------
        list[NormalizedRecord]
            Normalised recordings sorted by ``source_confidence``
            descending.
        """
        records: list[NormalizedRecord] = []

        for result in response.get("results", []):
            score = result.get("score", 0.0)
            acoustid_id = result.get("id", "")

            for recording in result.get("recordings", []):
                mbid = recording.get("id", "")
                title = recording.get("title", "")
                duration = recording.get("duration")

                artists = recording.get("artists", [])
                artist_names = [a.get("name", "") for a in artists if a.get("name")]

                record = NormalizedRecord(
                    source=SourceEnum.ACOUSTID,
                    source_id=acoustid_id,
                    entity_type=EntityTypeEnum.RECORDING,
                    canonical_name=title,
                    identifiers=IdentifierBundle(
                        mbid=mbid,
                        acoustid=acoustid_id,
                    ),
                    metadata=SourceMetadata(
                        roles=artist_names,
                        duration_ms=duration * 1000 if duration else None,
                    ),
                    fetch_timestamp=datetime.now(UTC),
                    source_confidence=score,
                    raw_payload=result,
                )
                records.append(record)

        # Sort by confidence descending
        records.sort(key=lambda r: r.source_confidence, reverse=True)
        return records

    async def _api_call(self, func, *args, **kwargs):
        """Make a rate-limited API call with exponential-backoff retry.

        Acquires a token from the rate limiter before each attempt, then
        delegates the synchronous ``acoustid`` call to a thread via
        ``asyncio.to_thread()``.

        Parameters
        ----------
        func : callable
            An ``acoustid`` function (e.g., ``acoustid.lookup``).
        *args : Any
            Positional arguments forwarded to *func*.
        **kwargs : Any
            Keyword arguments forwarded to *func*.

        Returns
        -------
        dict
            Raw API response dictionary.

        Raises
        ------
        acoustid.WebServiceError
            If all ``max_retries`` attempts fail.
        """
        for attempt in range(self._max_retries):
            await self._rate_limiter.acquire()
            try:
                return await asyncio.to_thread(func, *args, **kwargs)
            except acoustid.WebServiceError as e:
                if attempt < self._max_retries - 1:
                    wait = 2**attempt
                    logger.warning(
                        "AcoustID API error (attempt %d/%d): %s. Retrying in %ds.",
                        attempt + 1,
                        self._max_retries,
                        e,
                        wait,
                    )
                    await asyncio.sleep(wait)
                else:
                    raise
